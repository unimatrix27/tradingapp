/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.1.1.0 (NJsonSchema v9.1.12.0) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import 'rxjs/add/observable/fromPromise';
import 'rxjs/add/observable/of';
import 'rxjs/add/observable/throw';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/toPromise';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/catch';

import { Observable } from 'rxjs/Observable';
import { Injectable, Inject, Optional, OpaqueToken } from '@angular/core';
import { Http, Headers, ResponseContentType, Response } from '@angular/http';

import * as moment from 'moment';

export const WEBBASE = new OpaqueToken('WEBBASE');

export interface IClient {
    home_Index(): Observable<Blob | null>;
    sampleData_WeatherForecasts(): Observable<WeatherForecast[] | null>;
    brokers_GetBrokers(): Observable<BrokerResource[] | null>;
    brokerInstruments_GetBrokerInstrumentsForScreener(id: number): Observable<BrokerInstrumentResource[] | null>;
    brokerInstruments_GetBrokerInstruments(): Observable<InstrumentNameAllResource[] | null>;
    currencies_GetCurrencies(): Observable<CurrencyResource[] | null>;
    exchanges_GetExchanges(): Observable<ExchangeResource[] | null>;
    instrumentName_GetInstrumentNames(): Observable<InstrumentNameResource[] | null>;
    instrumentName_CreateInstrumentName(instrumentName: InstrumentName): Observable<Blob | null>;
    instrumentName_FindInstrumentNames(name: string): Observable<Blob | null>;
    instrumentName_UpdateInstrumentName(id: number, instrumentName: InstrumentName): Observable<Blob | null>;
    instrumentTypes_GetInstrumentTypes(): Observable<InstrumentTypeResource[] | null>;
    priceEntries_GetFull(screener: string, brokerInstrumentId: number, back: number, count: number, timeInterval: string): Observable<any[] | null>;
    refImage_UpdateInstrumentName(id: number, brokerInstrumentId: number): Observable<Blob | null>;
    refImage_nextRefImage(): Observable<Blob | null>;
    refImage_getRefImages(): Observable<Blob | null>;
    refImage_Show(imageId: number): Observable<ActionResult | null>;
    refImage_getCount(): Observable<number | null>;
    screeners_rescanScreener(id: number): Observable<Blob | null>;
    screeners_lastScreeners(): Observable<Screener[] | null>;
    signal_GetOpen(): Observable<SignalResource[] | null>;
    trade_GetTrades(): Observable<TradeResource[] | null>;
    trade_DiscardSignal(signalId: number): Observable<Blob | null>;
    trade_CreateTrade(signalId: number): Observable<Blob | null>;
    trade_CancelTrade(tradeId: number): Observable<TradeResource | null>;
    trade_UpdateTradeFromSignal(tradeId: number): Observable<TradeResource | null>;
    trade_UndoLastTradeStep(tradeId: number): Observable<TradeResource | null>;
    trade_Hide(tradeId: number): Observable<Blob | null>;
    trade_ConfirmPlaceTrade(tradeId: number): Observable<Blob | null>;
    trade_FilledTrade(tradeId: number, executedLevel: number): Observable<Blob | null>;
}

@Injectable()
export class Client implements IClient {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(WEBBASE) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://192.168.2.91:5000";
    }

    home_Index(): Observable<Blob | null> {
        let url_ = this.baseUrl + "/api/Home";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "post",
            responseType: ResponseContentType.Blob,
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processHome_Index(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processHome_Index(response_);
                } catch (e) {
                    return <Observable<Blob>><any>Observable.throw(e);
                }
            } else
                return <Observable<Blob>><any>Observable.throw(response_);
        });
    }

    protected processHome_Index(response: Response): Observable<Blob | null> {
        const status = response.status; 

        if (status === 200) {
            return Observable.of(response.blob());
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.blob()).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText);
            });
        }
        return Observable.of<Blob | null>(<any>null);
    }

    sampleData_WeatherForecasts(): Observable<WeatherForecast[] | null> {
        let url_ = this.baseUrl + "/api/SampleData/WeatherForecasts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processSampleData_WeatherForecasts(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSampleData_WeatherForecasts(response_);
                } catch (e) {
                    return <Observable<WeatherForecast[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<WeatherForecast[]>><any>Observable.throw(response_);
        });
    }

    protected processSampleData_WeatherForecasts(response: Response): Observable<WeatherForecast[] | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: WeatherForecast[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(WeatherForecast.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<WeatherForecast[] | null>(<any>null);
    }

    brokers_GetBrokers(): Observable<BrokerResource[] | null> {
        let url_ = this.baseUrl + "/api/brokers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processBrokers_GetBrokers(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processBrokers_GetBrokers(response_);
                } catch (e) {
                    return <Observable<BrokerResource[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<BrokerResource[]>><any>Observable.throw(response_);
        });
    }

    protected processBrokers_GetBrokers(response: Response): Observable<BrokerResource[] | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: BrokerResource[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BrokerResource.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<BrokerResource[] | null>(<any>null);
    }

    brokerInstruments_GetBrokerInstrumentsForScreener(id: number): Observable<BrokerInstrumentResource[] | null> {
        let url_ = this.baseUrl + "/api/brokerinstruments/screener/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processBrokerInstruments_GetBrokerInstrumentsForScreener(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processBrokerInstruments_GetBrokerInstrumentsForScreener(response_);
                } catch (e) {
                    return <Observable<BrokerInstrumentResource[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<BrokerInstrumentResource[]>><any>Observable.throw(response_);
        });
    }

    protected processBrokerInstruments_GetBrokerInstrumentsForScreener(response: Response): Observable<BrokerInstrumentResource[] | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: BrokerInstrumentResource[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BrokerInstrumentResource.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<BrokerInstrumentResource[] | null>(<any>null);
    }

    brokerInstruments_GetBrokerInstruments(): Observable<InstrumentNameAllResource[] | null> {
        let url_ = this.baseUrl + "/api/brokerinstruments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processBrokerInstruments_GetBrokerInstruments(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processBrokerInstruments_GetBrokerInstruments(response_);
                } catch (e) {
                    return <Observable<InstrumentNameAllResource[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<InstrumentNameAllResource[]>><any>Observable.throw(response_);
        });
    }

    protected processBrokerInstruments_GetBrokerInstruments(response: Response): Observable<InstrumentNameAllResource[] | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: InstrumentNameAllResource[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(InstrumentNameAllResource.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<InstrumentNameAllResource[] | null>(<any>null);
    }

    currencies_GetCurrencies(): Observable<CurrencyResource[] | null> {
        let url_ = this.baseUrl + "/api/currencies";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processCurrencies_GetCurrencies(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCurrencies_GetCurrencies(response_);
                } catch (e) {
                    return <Observable<CurrencyResource[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<CurrencyResource[]>><any>Observable.throw(response_);
        });
    }

    protected processCurrencies_GetCurrencies(response: Response): Observable<CurrencyResource[] | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: CurrencyResource[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CurrencyResource.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<CurrencyResource[] | null>(<any>null);
    }

    exchanges_GetExchanges(): Observable<ExchangeResource[] | null> {
        let url_ = this.baseUrl + "/api/exchanges";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processExchanges_GetExchanges(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processExchanges_GetExchanges(response_);
                } catch (e) {
                    return <Observable<ExchangeResource[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<ExchangeResource[]>><any>Observable.throw(response_);
        });
    }

    protected processExchanges_GetExchanges(response: Response): Observable<ExchangeResource[] | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: ExchangeResource[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ExchangeResource.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<ExchangeResource[] | null>(<any>null);
    }

    instrumentName_GetInstrumentNames(): Observable<InstrumentNameResource[] | null> {
        let url_ = this.baseUrl + "/api/instrumentnames";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processInstrumentName_GetInstrumentNames(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processInstrumentName_GetInstrumentNames(response_);
                } catch (e) {
                    return <Observable<InstrumentNameResource[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<InstrumentNameResource[]>><any>Observable.throw(response_);
        });
    }

    protected processInstrumentName_GetInstrumentNames(response: Response): Observable<InstrumentNameResource[] | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: InstrumentNameResource[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(InstrumentNameResource.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<InstrumentNameResource[] | null>(<any>null);
    }

    instrumentName_CreateInstrumentName(instrumentName: InstrumentName): Observable<Blob | null> {
        let url_ = this.baseUrl + "/api/instrumentnames";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(instrumentName);
        
        let options_ = {
            body: content_,
            method: "post",
            responseType: ResponseContentType.Blob,
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processInstrumentName_CreateInstrumentName(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processInstrumentName_CreateInstrumentName(response_);
                } catch (e) {
                    return <Observable<Blob>><any>Observable.throw(e);
                }
            } else
                return <Observable<Blob>><any>Observable.throw(response_);
        });
    }

    protected processInstrumentName_CreateInstrumentName(response: Response): Observable<Blob | null> {
        const status = response.status; 

        if (status === 200) {
            return Observable.of(response.blob());
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.blob()).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText);
            });
        }
        return Observable.of<Blob | null>(<any>null);
    }

    instrumentName_FindInstrumentNames(name: string): Observable<Blob | null> {
        let url_ = this.baseUrl + "/api/instrumentnames/find/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            responseType: ResponseContentType.Blob,
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processInstrumentName_FindInstrumentNames(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processInstrumentName_FindInstrumentNames(response_);
                } catch (e) {
                    return <Observable<Blob>><any>Observable.throw(e);
                }
            } else
                return <Observable<Blob>><any>Observable.throw(response_);
        });
    }

    protected processInstrumentName_FindInstrumentNames(response: Response): Observable<Blob | null> {
        const status = response.status; 

        if (status === 200) {
            return Observable.of(response.blob());
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.blob()).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText);
            });
        }
        return Observable.of<Blob | null>(<any>null);
    }

    instrumentName_UpdateInstrumentName(id: number, instrumentName: InstrumentName): Observable<Blob | null> {
        let url_ = this.baseUrl + "/api/instrumentnames/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(instrumentName);
        
        let options_ = {
            body: content_,
            method: "put",
            responseType: ResponseContentType.Blob,
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processInstrumentName_UpdateInstrumentName(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processInstrumentName_UpdateInstrumentName(response_);
                } catch (e) {
                    return <Observable<Blob>><any>Observable.throw(e);
                }
            } else
                return <Observable<Blob>><any>Observable.throw(response_);
        });
    }

    protected processInstrumentName_UpdateInstrumentName(response: Response): Observable<Blob | null> {
        const status = response.status; 

        if (status === 200) {
            return Observable.of(response.blob());
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.blob()).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText);
            });
        }
        return Observable.of<Blob | null>(<any>null);
    }

    instrumentTypes_GetInstrumentTypes(): Observable<InstrumentTypeResource[] | null> {
        let url_ = this.baseUrl + "/api/instrumenttypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processInstrumentTypes_GetInstrumentTypes(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processInstrumentTypes_GetInstrumentTypes(response_);
                } catch (e) {
                    return <Observable<InstrumentTypeResource[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<InstrumentTypeResource[]>><any>Observable.throw(response_);
        });
    }

    protected processInstrumentTypes_GetInstrumentTypes(response: Response): Observable<InstrumentTypeResource[] | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: InstrumentTypeResource[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(InstrumentTypeResource.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<InstrumentTypeResource[] | null>(<any>null);
    }

    priceEntries_GetFull(screener: string, brokerInstrumentId: number, back: number, count: number, timeInterval: string): Observable<any[] | null> {
        let url_ = this.baseUrl + "/api/pricesfull?";
        if (screener === undefined)
            throw new Error("The parameter 'screener' must be defined.");
        else
            url_ += "screener=" + encodeURIComponent("" + screener) + "&"; 
        if (brokerInstrumentId === undefined || brokerInstrumentId === null)
            throw new Error("The parameter 'brokerInstrumentId' must be defined and cannot be null.");
        else
            url_ += "brokerInstrumentId=" + encodeURIComponent("" + brokerInstrumentId) + "&"; 
        if (back === undefined || back === null)
            throw new Error("The parameter 'back' must be defined and cannot be null.");
        else
            url_ += "back=" + encodeURIComponent("" + back) + "&"; 
        if (count === undefined || count === null)
            throw new Error("The parameter 'count' must be defined and cannot be null.");
        else
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (timeInterval !== undefined)
            url_ += "timeInterval=" + encodeURIComponent("" + timeInterval) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processPriceEntries_GetFull(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processPriceEntries_GetFull(response_);
                } catch (e) {
                    return <Observable<any[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<any[]>><any>Observable.throw(response_);
        });
    }

    protected processPriceEntries_GetFull(response: Response): Observable<any[] | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: any[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<any[] | null>(<any>null);
    }

    refImage_UpdateInstrumentName(id: number, brokerInstrumentId: number): Observable<Blob | null> {
        let url_ = this.baseUrl + "/api/refimages/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(brokerInstrumentId);
        
        let options_ = {
            body: content_,
            method: "put",
            responseType: ResponseContentType.Blob,
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processRefImage_UpdateInstrumentName(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRefImage_UpdateInstrumentName(response_);
                } catch (e) {
                    return <Observable<Blob>><any>Observable.throw(e);
                }
            } else
                return <Observable<Blob>><any>Observable.throw(response_);
        });
    }

    protected processRefImage_UpdateInstrumentName(response: Response): Observable<Blob | null> {
        const status = response.status; 

        if (status === 200) {
            return Observable.of(response.blob());
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.blob()).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText);
            });
        }
        return Observable.of<Blob | null>(<any>null);
    }

    refImage_nextRefImage(): Observable<Blob | null> {
        let url_ = this.baseUrl + "/api/refimages/next";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            responseType: ResponseContentType.Blob,
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processRefImage_nextRefImage(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRefImage_nextRefImage(response_);
                } catch (e) {
                    return <Observable<Blob>><any>Observable.throw(e);
                }
            } else
                return <Observable<Blob>><any>Observable.throw(response_);
        });
    }

    protected processRefImage_nextRefImage(response: Response): Observable<Blob | null> {
        const status = response.status; 

        if (status === 200) {
            return Observable.of(response.blob());
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.blob()).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText);
            });
        }
        return Observable.of<Blob | null>(<any>null);
    }

    refImage_getRefImages(): Observable<Blob | null> {
        let url_ = this.baseUrl + "/api/refimages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            responseType: ResponseContentType.Blob,
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processRefImage_getRefImages(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRefImage_getRefImages(response_);
                } catch (e) {
                    return <Observable<Blob>><any>Observable.throw(e);
                }
            } else
                return <Observable<Blob>><any>Observable.throw(response_);
        });
    }

    protected processRefImage_getRefImages(response: Response): Observable<Blob | null> {
        const status = response.status; 

        if (status === 200) {
            return Observable.of(response.blob());
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.blob()).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText);
            });
        }
        return Observable.of<Blob | null>(<any>null);
    }

    refImage_Show(imageId: number): Observable<ActionResult | null> {
        let url_ = this.baseUrl + "/api/refimages//refimages/show/{imageId}";
        if (imageId === undefined || imageId === null)
            throw new Error("The parameter 'imageId' must be defined.");
        url_ = url_.replace("{imageId}", encodeURIComponent("" + imageId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processRefImage_Show(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRefImage_Show(response_);
                } catch (e) {
                    return <Observable<ActionResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<ActionResult>><any>Observable.throw(response_);
        });
    }

    protected processRefImage_Show(response: Response): Observable<ActionResult | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: ActionResult | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActionResult.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<ActionResult | null>(<any>null);
    }

    refImage_getCount(): Observable<number | null> {
        let url_ = this.baseUrl + "/api/refimages/count";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processRefImage_getCount(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRefImage_getCount(response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processRefImage_getCount(response: Response): Observable<number | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: number | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<number | null>(<any>null);
    }

    screeners_rescanScreener(id: number): Observable<Blob | null> {
        let url_ = this.baseUrl + "/api/screeners/rescan/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "put",
            responseType: ResponseContentType.Blob,
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processScreeners_rescanScreener(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processScreeners_rescanScreener(response_);
                } catch (e) {
                    return <Observable<Blob>><any>Observable.throw(e);
                }
            } else
                return <Observable<Blob>><any>Observable.throw(response_);
        });
    }

    protected processScreeners_rescanScreener(response: Response): Observable<Blob | null> {
        const status = response.status; 

        if (status === 200) {
            return Observable.of(response.blob());
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.blob()).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText);
            });
        }
        return Observable.of<Blob | null>(<any>null);
    }

    screeners_lastScreeners(): Observable<Screener[] | null> {
        let url_ = this.baseUrl + "/api/screeners/last";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processScreeners_lastScreeners(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processScreeners_lastScreeners(response_);
                } catch (e) {
                    return <Observable<Screener[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Screener[]>><any>Observable.throw(response_);
        });
    }

    protected processScreeners_lastScreeners(response: Response): Observable<Screener[] | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: Screener[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Screener.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<Screener[] | null>(<any>null);
    }

    signal_GetOpen(): Observable<SignalResource[] | null> {
        let url_ = this.baseUrl + "/api/signals";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processSignal_GetOpen(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSignal_GetOpen(response_);
                } catch (e) {
                    return <Observable<SignalResource[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<SignalResource[]>><any>Observable.throw(response_);
        });
    }

    protected processSignal_GetOpen(response: Response): Observable<SignalResource[] | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: SignalResource[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SignalResource.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<SignalResource[] | null>(<any>null);
    }

    trade_GetTrades(): Observable<TradeResource[] | null> {
        let url_ = this.baseUrl + "/api/trades";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processTrade_GetTrades(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processTrade_GetTrades(response_);
                } catch (e) {
                    return <Observable<TradeResource[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<TradeResource[]>><any>Observable.throw(response_);
        });
    }

    protected processTrade_GetTrades(response: Response): Observable<TradeResource[] | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: TradeResource[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TradeResource.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<TradeResource[] | null>(<any>null);
    }

    trade_DiscardSignal(signalId: number): Observable<Blob | null> {
        let url_ = this.baseUrl + "/api/trades/Discard";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(signalId);
        
        let options_ = {
            body: content_,
            method: "post",
            responseType: ResponseContentType.Blob,
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processTrade_DiscardSignal(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processTrade_DiscardSignal(response_);
                } catch (e) {
                    return <Observable<Blob>><any>Observable.throw(e);
                }
            } else
                return <Observable<Blob>><any>Observable.throw(response_);
        });
    }

    protected processTrade_DiscardSignal(response: Response): Observable<Blob | null> {
        const status = response.status; 

        if (status === 200) {
            return Observable.of(response.blob());
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.blob()).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText);
            });
        }
        return Observable.of<Blob | null>(<any>null);
    }

    trade_CreateTrade(signalId: number): Observable<Blob | null> {
        let url_ = this.baseUrl + "/api/trades/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(signalId);
        
        let options_ = {
            body: content_,
            method: "post",
            responseType: ResponseContentType.Blob,
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processTrade_CreateTrade(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processTrade_CreateTrade(response_);
                } catch (e) {
                    return <Observable<Blob>><any>Observable.throw(e);
                }
            } else
                return <Observable<Blob>><any>Observable.throw(response_);
        });
    }

    protected processTrade_CreateTrade(response: Response): Observable<Blob | null> {
        const status = response.status; 

        if (status === 200) {
            return Observable.of(response.blob());
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.blob()).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText);
            });
        }
        return Observable.of<Blob | null>(<any>null);
    }

    trade_CancelTrade(tradeId: number): Observable<TradeResource | null> {
        let url_ = this.baseUrl + "/api/trades/Cancel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tradeId);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processTrade_CancelTrade(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processTrade_CancelTrade(response_);
                } catch (e) {
                    return <Observable<TradeResource>><any>Observable.throw(e);
                }
            } else
                return <Observable<TradeResource>><any>Observable.throw(response_);
        });
    }

    protected processTrade_CancelTrade(response: Response): Observable<TradeResource | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: TradeResource | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TradeResource.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<TradeResource | null>(<any>null);
    }

    trade_UpdateTradeFromSignal(tradeId: number): Observable<TradeResource | null> {
        let url_ = this.baseUrl + "/api/trades/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tradeId);
        
        let options_ = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processTrade_UpdateTradeFromSignal(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processTrade_UpdateTradeFromSignal(response_);
                } catch (e) {
                    return <Observable<TradeResource>><any>Observable.throw(e);
                }
            } else
                return <Observable<TradeResource>><any>Observable.throw(response_);
        });
    }

    protected processTrade_UpdateTradeFromSignal(response: Response): Observable<TradeResource | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: TradeResource | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TradeResource.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<TradeResource | null>(<any>null);
    }

    trade_UndoLastTradeStep(tradeId: number): Observable<TradeResource | null> {
        let url_ = this.baseUrl + "/api/trades/Undo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tradeId);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processTrade_UndoLastTradeStep(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processTrade_UndoLastTradeStep(response_);
                } catch (e) {
                    return <Observable<TradeResource>><any>Observable.throw(e);
                }
            } else
                return <Observable<TradeResource>><any>Observable.throw(response_);
        });
    }

    protected processTrade_UndoLastTradeStep(response: Response): Observable<TradeResource | null> {
        const status = response.status; 

        if (status === 200) {
            const _responseText = response.text();
            let result200: TradeResource | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TradeResource.fromJS(resultData200) : <any>null;
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText);
        }
        return Observable.of<TradeResource | null>(<any>null);
    }

    trade_Hide(tradeId: number): Observable<Blob | null> {
        let url_ = this.baseUrl + "/api/trades/Hide";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tradeId);
        
        let options_ = {
            body: content_,
            method: "post",
            responseType: ResponseContentType.Blob,
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processTrade_Hide(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processTrade_Hide(response_);
                } catch (e) {
                    return <Observable<Blob>><any>Observable.throw(e);
                }
            } else
                return <Observable<Blob>><any>Observable.throw(response_);
        });
    }

    protected processTrade_Hide(response: Response): Observable<Blob | null> {
        const status = response.status; 

        if (status === 200) {
            return Observable.of(response.blob());
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.blob()).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText);
            });
        }
        return Observable.of<Blob | null>(<any>null);
    }

    trade_ConfirmPlaceTrade(tradeId: number): Observable<Blob | null> {
        let url_ = this.baseUrl + "/api/trades/Confirm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tradeId);
        
        let options_ = {
            body: content_,
            method: "post",
            responseType: ResponseContentType.Blob,
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processTrade_ConfirmPlaceTrade(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processTrade_ConfirmPlaceTrade(response_);
                } catch (e) {
                    return <Observable<Blob>><any>Observable.throw(e);
                }
            } else
                return <Observable<Blob>><any>Observable.throw(response_);
        });
    }

    protected processTrade_ConfirmPlaceTrade(response: Response): Observable<Blob | null> {
        const status = response.status; 

        if (status === 200) {
            return Observable.of(response.blob());
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.blob()).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText);
            });
        }
        return Observable.of<Blob | null>(<any>null);
    }

    trade_FilledTrade(tradeId: number, executedLevel: number): Observable<Blob | null> {
        let url_ = this.baseUrl + "/api/trades/Filled?";
        if (executedLevel === undefined || executedLevel === null)
            throw new Error("The parameter 'executedLevel' must be defined and cannot be null.");
        else
            url_ += "executedLevel=" + encodeURIComponent("" + executedLevel) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tradeId);
        
        let options_ = {
            body: content_,
            method: "post",
            responseType: ResponseContentType.Blob,
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processTrade_FilledTrade(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processTrade_FilledTrade(response_);
                } catch (e) {
                    return <Observable<Blob>><any>Observable.throw(e);
                }
            } else
                return <Observable<Blob>><any>Observable.throw(response_);
        });
    }

    protected processTrade_FilledTrade(response: Response): Observable<Blob | null> {
        const status = response.status; 

        if (status === 200) {
            return Observable.of(response.blob());
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.blob()).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText);
            });
        }
        return Observable.of<Blob | null>(<any>null);
    }
}

export class WeatherForecast implements IWeatherForecast {
    dateFormatted?: string | null;
    temperatureC: number;
    summary?: string | null;
    temperatureF: number;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dateFormatted = data["dateFormatted"] !== undefined ? data["dateFormatted"] : <any>null;
            this.temperatureC = data["temperatureC"] !== undefined ? data["temperatureC"] : <any>null;
            this.summary = data["summary"] !== undefined ? data["summary"] : <any>null;
            this.temperatureF = data["temperatureF"] !== undefined ? data["temperatureF"] : <any>null;
        }
    }

    static fromJS(data: any): WeatherForecast {
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateFormatted"] = this.dateFormatted !== undefined ? this.dateFormatted : <any>null;
        data["temperatureC"] = this.temperatureC !== undefined ? this.temperatureC : <any>null;
        data["summary"] = this.summary !== undefined ? this.summary : <any>null;
        data["temperatureF"] = this.temperatureF !== undefined ? this.temperatureF : <any>null;
        return data; 
    }
}

export interface IWeatherForecast {
    dateFormatted?: string | null;
    temperatureC: number;
    summary?: string | null;
    temperatureF: number;
}

export class BrokerResource implements IBrokerResource {
    id: number;
    created?: moment.Moment | null;
    updated?: moment.Moment | null;
    name?: string | null;
    shortName?: string | null;
    exchanges?: ExchangeResource[] | null;

    constructor(data?: IBrokerResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.created = data["created"] ? moment(data["created"].toString()) : <any>null;
            this.updated = data["updated"] ? moment(data["updated"].toString()) : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.shortName = data["shortName"] !== undefined ? data["shortName"] : <any>null;
            if (data["exchanges"] && data["exchanges"].constructor === Array) {
                this.exchanges = [];
                for (let item of data["exchanges"])
                    this.exchanges.push(ExchangeResource.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BrokerResource {
        let result = new BrokerResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["created"] = this.created ? this.created.toISOString() : <any>null;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["shortName"] = this.shortName !== undefined ? this.shortName : <any>null;
        if (this.exchanges && this.exchanges.constructor === Array) {
            data["exchanges"] = [];
            for (let item of this.exchanges)
                data["exchanges"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IBrokerResource {
    id: number;
    created?: moment.Moment | null;
    updated?: moment.Moment | null;
    name?: string | null;
    shortName?: string | null;
    exchanges?: ExchangeResource[] | null;
}

export class ExchangeResource implements IExchangeResource {
    id: number;
    created?: moment.Moment | null;
    updated?: moment.Moment | null;
    name?: string | null;
    currencyId: number;
    currency?: CurrencyResource | null;
    brokerId: number;
    isOpen: boolean;
    timeZoneId?: string | null;
    timeZone?: TimeZoneInfo | null;
    openTime: moment.Moment;
    closeTime: moment.Moment;
    lastCloseTime: moment.Moment;

    constructor(data?: IExchangeResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.created = data["created"] ? moment(data["created"].toString()) : <any>null;
            this.updated = data["updated"] ? moment(data["updated"].toString()) : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.currencyId = data["currencyId"] !== undefined ? data["currencyId"] : <any>null;
            this.currency = data["currency"] ? CurrencyResource.fromJS(data["currency"]) : <any>null;
            this.brokerId = data["brokerId"] !== undefined ? data["brokerId"] : <any>null;
            this.isOpen = data["isOpen"] !== undefined ? data["isOpen"] : <any>null;
            this.timeZoneId = data["timeZoneId"] !== undefined ? data["timeZoneId"] : <any>null;
            this.timeZone = data["timeZone"] ? TimeZoneInfo.fromJS(data["timeZone"]) : <any>null;
            this.openTime = data["openTime"] ? moment(data["openTime"].toString()) : <any>null;
            this.closeTime = data["closeTime"] ? moment(data["closeTime"].toString()) : <any>null;
            this.lastCloseTime = data["lastCloseTime"] ? moment(data["lastCloseTime"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): ExchangeResource {
        let result = new ExchangeResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["created"] = this.created ? this.created.toISOString() : <any>null;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["currencyId"] = this.currencyId !== undefined ? this.currencyId : <any>null;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
        data["brokerId"] = this.brokerId !== undefined ? this.brokerId : <any>null;
        data["isOpen"] = this.isOpen !== undefined ? this.isOpen : <any>null;
        data["timeZoneId"] = this.timeZoneId !== undefined ? this.timeZoneId : <any>null;
        data["timeZone"] = this.timeZone ? this.timeZone.toJSON() : <any>null;
        data["openTime"] = this.openTime ? this.openTime.toISOString() : <any>null;
        data["closeTime"] = this.closeTime ? this.closeTime.toISOString() : <any>null;
        data["lastCloseTime"] = this.lastCloseTime ? this.lastCloseTime.toISOString() : <any>null;
        return data; 
    }
}

export interface IExchangeResource {
    id: number;
    created?: moment.Moment | null;
    updated?: moment.Moment | null;
    name?: string | null;
    currencyId: number;
    currency?: CurrencyResource | null;
    brokerId: number;
    isOpen: boolean;
    timeZoneId?: string | null;
    timeZone?: TimeZoneInfo | null;
    openTime: moment.Moment;
    closeTime: moment.Moment;
    lastCloseTime: moment.Moment;
}

export class CurrencyResource implements ICurrencyResource {
    id: number;
    created?: moment.Moment | null;
    updated?: moment.Moment | null;
    name?: string | null;
    rate: number;

    constructor(data?: ICurrencyResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.created = data["created"] ? moment(data["created"].toString()) : <any>null;
            this.updated = data["updated"] ? moment(data["updated"].toString()) : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.rate = data["rate"] !== undefined ? data["rate"] : <any>null;
        }
    }

    static fromJS(data: any): CurrencyResource {
        let result = new CurrencyResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["created"] = this.created ? this.created.toISOString() : <any>null;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["rate"] = this.rate !== undefined ? this.rate : <any>null;
        return data; 
    }
}

export interface ICurrencyResource {
    id: number;
    created?: moment.Moment | null;
    updated?: moment.Moment | null;
    name?: string | null;
    rate: number;
}

export class TimeZoneInfo implements ITimeZoneInfo {
    id?: string | null;
    displayName?: string | null;
    standardName?: string | null;
    daylightName?: string | null;
    baseUtcOffset: moment.Moment;
    supportsDaylightSavingTime: boolean;
    local?: TimeZoneInfo | null;
    utc?: TimeZoneInfo | null;

    constructor(data?: ITimeZoneInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.displayName = data["displayName"] !== undefined ? data["displayName"] : <any>null;
            this.standardName = data["standardName"] !== undefined ? data["standardName"] : <any>null;
            this.daylightName = data["daylightName"] !== undefined ? data["daylightName"] : <any>null;
            this.baseUtcOffset = data["baseUtcOffset"] ? moment(data["baseUtcOffset"].toString()) : <any>null;
            this.supportsDaylightSavingTime = data["supportsDaylightSavingTime"] !== undefined ? data["supportsDaylightSavingTime"] : <any>null;
            this.local = data["local"] ? TimeZoneInfo.fromJS(data["local"]) : <any>null;
            this.utc = data["utc"] ? TimeZoneInfo.fromJS(data["utc"]) : <any>null;
        }
    }

    static fromJS(data: any): TimeZoneInfo {
        let result = new TimeZoneInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["displayName"] = this.displayName !== undefined ? this.displayName : <any>null;
        data["standardName"] = this.standardName !== undefined ? this.standardName : <any>null;
        data["daylightName"] = this.daylightName !== undefined ? this.daylightName : <any>null;
        data["baseUtcOffset"] = this.baseUtcOffset ? this.baseUtcOffset.toISOString() : <any>null;
        data["supportsDaylightSavingTime"] = this.supportsDaylightSavingTime !== undefined ? this.supportsDaylightSavingTime : <any>null;
        data["local"] = this.local ? this.local.toJSON() : <any>null;
        data["utc"] = this.utc ? this.utc.toJSON() : <any>null;
        return data; 
    }
}

export interface ITimeZoneInfo {
    id?: string | null;
    displayName?: string | null;
    standardName?: string | null;
    daylightName?: string | null;
    baseUtcOffset: moment.Moment;
    supportsDaylightSavingTime: boolean;
    local?: TimeZoneInfo | null;
    utc?: TimeZoneInfo | null;
}

export class BrokerInstrumentResource implements IBrokerInstrumentResource {
    id: number;
    created?: moment.Moment | null;
    updated?: moment.Moment | null;
    brokerSymbolId: number;
    instrumentTypeId: number;
    exchangeId: number;
    expiry?: string | null;
    multiplicator?: number | null;
    instrumentType?: InstrumentTypeResource | null;
    exchangeName?: string | null;
    brokerName?: string | null;
    typeName?: string | null;
    symbolName?: string | null;
    currencyName?: string | null;
    instrumentNameName?: string | null;
    instrumentNameId: number;

    constructor(data?: IBrokerInstrumentResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.created = data["created"] ? moment(data["created"].toString()) : <any>null;
            this.updated = data["updated"] ? moment(data["updated"].toString()) : <any>null;
            this.brokerSymbolId = data["brokerSymbolId"] !== undefined ? data["brokerSymbolId"] : <any>null;
            this.instrumentTypeId = data["instrumentTypeId"] !== undefined ? data["instrumentTypeId"] : <any>null;
            this.exchangeId = data["exchangeId"] !== undefined ? data["exchangeId"] : <any>null;
            this.expiry = data["expiry"] !== undefined ? data["expiry"] : <any>null;
            this.multiplicator = data["multiplicator"] !== undefined ? data["multiplicator"] : <any>null;
            this.instrumentType = data["instrumentType"] ? InstrumentTypeResource.fromJS(data["instrumentType"]) : <any>null;
            this.exchangeName = data["exchangeName"] !== undefined ? data["exchangeName"] : <any>null;
            this.brokerName = data["brokerName"] !== undefined ? data["brokerName"] : <any>null;
            this.typeName = data["typeName"] !== undefined ? data["typeName"] : <any>null;
            this.symbolName = data["symbolName"] !== undefined ? data["symbolName"] : <any>null;
            this.currencyName = data["currencyName"] !== undefined ? data["currencyName"] : <any>null;
            this.instrumentNameName = data["instrumentNameName"] !== undefined ? data["instrumentNameName"] : <any>null;
            this.instrumentNameId = data["instrumentNameId"] !== undefined ? data["instrumentNameId"] : <any>null;
        }
    }

    static fromJS(data: any): BrokerInstrumentResource {
        let result = new BrokerInstrumentResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["created"] = this.created ? this.created.toISOString() : <any>null;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>null;
        data["brokerSymbolId"] = this.brokerSymbolId !== undefined ? this.brokerSymbolId : <any>null;
        data["instrumentTypeId"] = this.instrumentTypeId !== undefined ? this.instrumentTypeId : <any>null;
        data["exchangeId"] = this.exchangeId !== undefined ? this.exchangeId : <any>null;
        data["expiry"] = this.expiry !== undefined ? this.expiry : <any>null;
        data["multiplicator"] = this.multiplicator !== undefined ? this.multiplicator : <any>null;
        data["instrumentType"] = this.instrumentType ? this.instrumentType.toJSON() : <any>null;
        data["exchangeName"] = this.exchangeName !== undefined ? this.exchangeName : <any>null;
        data["brokerName"] = this.brokerName !== undefined ? this.brokerName : <any>null;
        data["typeName"] = this.typeName !== undefined ? this.typeName : <any>null;
        data["symbolName"] = this.symbolName !== undefined ? this.symbolName : <any>null;
        data["currencyName"] = this.currencyName !== undefined ? this.currencyName : <any>null;
        data["instrumentNameName"] = this.instrumentNameName !== undefined ? this.instrumentNameName : <any>null;
        data["instrumentNameId"] = this.instrumentNameId !== undefined ? this.instrumentNameId : <any>null;
        return data; 
    }
}

export interface IBrokerInstrumentResource {
    id: number;
    created?: moment.Moment | null;
    updated?: moment.Moment | null;
    brokerSymbolId: number;
    instrumentTypeId: number;
    exchangeId: number;
    expiry?: string | null;
    multiplicator?: number | null;
    instrumentType?: InstrumentTypeResource | null;
    exchangeName?: string | null;
    brokerName?: string | null;
    typeName?: string | null;
    symbolName?: string | null;
    currencyName?: string | null;
    instrumentNameName?: string | null;
    instrumentNameId: number;
}

export class InstrumentTypeResource implements IInstrumentTypeResource {
    id: number;
    created?: moment.Moment | null;
    updated?: moment.Moment | null;
    name?: string | null;

    constructor(data?: IInstrumentTypeResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.created = data["created"] ? moment(data["created"].toString()) : <any>null;
            this.updated = data["updated"] ? moment(data["updated"].toString()) : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): InstrumentTypeResource {
        let result = new InstrumentTypeResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["created"] = this.created ? this.created.toISOString() : <any>null;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IInstrumentTypeResource {
    id: number;
    created?: moment.Moment | null;
    updated?: moment.Moment | null;
    name?: string | null;
}

export class InstrumentNameAllResource implements IInstrumentNameAllResource {
    id: number;
    brokerInstrumentId: number;
    brokerSymbolId: number;
    name?: string | null;
    brokerSymbol?: string | null;
    broker?: string | null;
    exchange?: string | null;
    currency?: string | null;
    type?: string | null;
    expiry?: string | null;
    screener?: string | null;
    lastPriceEntry?: PriceEntryResource | null;
    multiplicator?: number | null;

    constructor(data?: IInstrumentNameAllResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.brokerInstrumentId = data["brokerInstrumentId"] !== undefined ? data["brokerInstrumentId"] : <any>null;
            this.brokerSymbolId = data["brokerSymbolId"] !== undefined ? data["brokerSymbolId"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.brokerSymbol = data["brokerSymbol"] !== undefined ? data["brokerSymbol"] : <any>null;
            this.broker = data["broker"] !== undefined ? data["broker"] : <any>null;
            this.exchange = data["exchange"] !== undefined ? data["exchange"] : <any>null;
            this.currency = data["currency"] !== undefined ? data["currency"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
            this.expiry = data["expiry"] !== undefined ? data["expiry"] : <any>null;
            this.screener = data["screener"] !== undefined ? data["screener"] : <any>null;
            this.lastPriceEntry = data["lastPriceEntry"] ? PriceEntryResource.fromJS(data["lastPriceEntry"]) : <any>null;
            this.multiplicator = data["multiplicator"] !== undefined ? data["multiplicator"] : <any>null;
        }
    }

    static fromJS(data: any): InstrumentNameAllResource {
        let result = new InstrumentNameAllResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["brokerInstrumentId"] = this.brokerInstrumentId !== undefined ? this.brokerInstrumentId : <any>null;
        data["brokerSymbolId"] = this.brokerSymbolId !== undefined ? this.brokerSymbolId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["brokerSymbol"] = this.brokerSymbol !== undefined ? this.brokerSymbol : <any>null;
        data["broker"] = this.broker !== undefined ? this.broker : <any>null;
        data["exchange"] = this.exchange !== undefined ? this.exchange : <any>null;
        data["currency"] = this.currency !== undefined ? this.currency : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["expiry"] = this.expiry !== undefined ? this.expiry : <any>null;
        data["screener"] = this.screener !== undefined ? this.screener : <any>null;
        data["lastPriceEntry"] = this.lastPriceEntry ? this.lastPriceEntry.toJSON() : <any>null;
        data["multiplicator"] = this.multiplicator !== undefined ? this.multiplicator : <any>null;
        return data; 
    }
}

export interface IInstrumentNameAllResource {
    id: number;
    brokerInstrumentId: number;
    brokerSymbolId: number;
    name?: string | null;
    brokerSymbol?: string | null;
    broker?: string | null;
    exchange?: string | null;
    currency?: string | null;
    type?: string | null;
    expiry?: string | null;
    screener?: string | null;
    lastPriceEntry?: PriceEntryResource | null;
    multiplicator?: number | null;
}

export class PriceEntryResource implements IPriceEntryResource {
    open: number;
    high: number;
    low: number;
    close: number;
    volume?: number | null;
    timeStamp: moment.Moment;
    isFinished: boolean;
    timeIntervalId: number;
    brokerInstrumentId: number;
    timeInterval?: TimeInterval | null;

    constructor(data?: IPriceEntryResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.open = data["open"] !== undefined ? data["open"] : <any>null;
            this.high = data["high"] !== undefined ? data["high"] : <any>null;
            this.low = data["low"] !== undefined ? data["low"] : <any>null;
            this.close = data["close"] !== undefined ? data["close"] : <any>null;
            this.volume = data["volume"] !== undefined ? data["volume"] : <any>null;
            this.timeStamp = data["timeStamp"] ? moment(data["timeStamp"].toString()) : <any>null;
            this.isFinished = data["isFinished"] !== undefined ? data["isFinished"] : <any>null;
            this.timeIntervalId = data["timeIntervalId"] !== undefined ? data["timeIntervalId"] : <any>null;
            this.brokerInstrumentId = data["brokerInstrumentId"] !== undefined ? data["brokerInstrumentId"] : <any>null;
            this.timeInterval = data["timeInterval"] ? TimeInterval.fromJS(data["timeInterval"]) : <any>null;
        }
    }

    static fromJS(data: any): PriceEntryResource {
        let result = new PriceEntryResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["open"] = this.open !== undefined ? this.open : <any>null;
        data["high"] = this.high !== undefined ? this.high : <any>null;
        data["low"] = this.low !== undefined ? this.low : <any>null;
        data["close"] = this.close !== undefined ? this.close : <any>null;
        data["volume"] = this.volume !== undefined ? this.volume : <any>null;
        data["timeStamp"] = this.timeStamp ? this.timeStamp.toISOString() : <any>null;
        data["isFinished"] = this.isFinished !== undefined ? this.isFinished : <any>null;
        data["timeIntervalId"] = this.timeIntervalId !== undefined ? this.timeIntervalId : <any>null;
        data["brokerInstrumentId"] = this.brokerInstrumentId !== undefined ? this.brokerInstrumentId : <any>null;
        data["timeInterval"] = this.timeInterval ? this.timeInterval.toJSON() : <any>null;
        return data; 
    }
}

export interface IPriceEntryResource {
    open: number;
    high: number;
    low: number;
    close: number;
    volume?: number | null;
    timeStamp: moment.Moment;
    isFinished: boolean;
    timeIntervalId: number;
    brokerInstrumentId: number;
    timeInterval?: TimeInterval | null;
}

export class BaseTable implements IBaseTable {
    id: number;
    created?: moment.Moment | null;
    updated?: moment.Moment | null;

    constructor(data?: IBaseTable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.created = data["created"] ? moment(data["created"].toString()) : <any>null;
            this.updated = data["updated"] ? moment(data["updated"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): BaseTable {
        let result = new BaseTable();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["created"] = this.created ? this.created.toISOString() : <any>null;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>null;
        return data; 
    }
}

export interface IBaseTable {
    id: number;
    created?: moment.Moment | null;
    updated?: moment.Moment | null;
}

export class TimeInterval extends BaseTable implements ITimeInterval {
    name: string;
    durationTicks: number;
    duration: moment.Moment;
    brokerTimeIntervals?: BrokerTimeInterval[] | null;

    constructor(data?: ITimeInterval) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.durationTicks = data["durationTicks"] !== undefined ? data["durationTicks"] : <any>null;
            this.duration = data["duration"] ? moment(data["duration"].toString()) : <any>null;
            if (data["brokerTimeIntervals"] && data["brokerTimeIntervals"].constructor === Array) {
                this.brokerTimeIntervals = [];
                for (let item of data["brokerTimeIntervals"])
                    this.brokerTimeIntervals.push(BrokerTimeInterval.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TimeInterval {
        let result = new TimeInterval();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["durationTicks"] = this.durationTicks !== undefined ? this.durationTicks : <any>null;
        data["duration"] = this.duration ? this.duration.toISOString() : <any>null;
        if (this.brokerTimeIntervals && this.brokerTimeIntervals.constructor === Array) {
            data["brokerTimeIntervals"] = [];
            for (let item of this.brokerTimeIntervals)
                data["brokerTimeIntervals"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ITimeInterval extends IBaseTable {
    name: string;
    durationTicks: number;
    duration: moment.Moment;
    brokerTimeIntervals?: BrokerTimeInterval[] | null;
}

export class BrokerTimeInterval extends BaseTable implements IBrokerTimeInterval {
    timeIntervalId: number;
    brokerId: number;
    timeInterval?: TimeInterval | null;
    broker: Broker = new Broker();
    brokerName: string;
    dataPriority: number;

    constructor(data?: IBrokerTimeInterval) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.timeIntervalId = data["timeIntervalId"] !== undefined ? data["timeIntervalId"] : <any>null;
            this.brokerId = data["brokerId"] !== undefined ? data["brokerId"] : <any>null;
            this.timeInterval = data["timeInterval"] ? TimeInterval.fromJS(data["timeInterval"]) : <any>null;
            this.broker = data["broker"] ? Broker.fromJS(data["broker"]) : new Broker();
            this.brokerName = data["brokerName"] !== undefined ? data["brokerName"] : <any>null;
            this.dataPriority = data["dataPriority"] !== undefined ? data["dataPriority"] : <any>null;
        }
    }

    static fromJS(data: any): BrokerTimeInterval {
        let result = new BrokerTimeInterval();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeIntervalId"] = this.timeIntervalId !== undefined ? this.timeIntervalId : <any>null;
        data["brokerId"] = this.brokerId !== undefined ? this.brokerId : <any>null;
        data["timeInterval"] = this.timeInterval ? this.timeInterval.toJSON() : <any>null;
        data["broker"] = this.broker ? this.broker.toJSON() : <any>null;
        data["brokerName"] = this.brokerName !== undefined ? this.brokerName : <any>null;
        data["dataPriority"] = this.dataPriority !== undefined ? this.dataPriority : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface IBrokerTimeInterval extends IBaseTable {
    timeIntervalId: number;
    brokerId: number;
    timeInterval?: TimeInterval | null;
    broker: Broker;
    brokerName: string;
    dataPriority: number;
}

export class Broker extends BaseTable implements IBroker {
    name: string;
    shortName?: string | null;
    exchanges?: Exchange[] | null;

    constructor(data?: IBroker) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.shortName = data["shortName"] !== undefined ? data["shortName"] : <any>null;
            if (data["exchanges"] && data["exchanges"].constructor === Array) {
                this.exchanges = [];
                for (let item of data["exchanges"])
                    this.exchanges.push(Exchange.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Broker {
        let result = new Broker();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["shortName"] = this.shortName !== undefined ? this.shortName : <any>null;
        if (this.exchanges && this.exchanges.constructor === Array) {
            data["exchanges"] = [];
            for (let item of this.exchanges)
                data["exchanges"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IBroker extends IBaseTable {
    name: string;
    shortName?: string | null;
    exchanges?: Exchange[] | null;
}

export class Exchange extends BaseTable implements IExchange {
    name: string;
    currencyId: number;
    currency: Currency = new Currency();
    brokerId: number;
    broker?: Broker | null;
    timeZoneId?: string | null;
    timeZone?: TimeZoneInfo | null;
    openTime: moment.Moment;
    closeTime: moment.Moment;
    isOpen: boolean;
    lastCloseTime: moment.Moment;

    constructor(data?: IExchange) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.currencyId = data["currencyId"] !== undefined ? data["currencyId"] : <any>null;
            this.currency = data["currency"] ? Currency.fromJS(data["currency"]) : new Currency();
            this.brokerId = data["brokerId"] !== undefined ? data["brokerId"] : <any>null;
            this.broker = data["broker"] ? Broker.fromJS(data["broker"]) : <any>null;
            this.timeZoneId = data["timeZoneId"] !== undefined ? data["timeZoneId"] : <any>null;
            this.timeZone = data["timeZone"] ? TimeZoneInfo.fromJS(data["timeZone"]) : <any>null;
            this.openTime = data["openTime"] ? moment(data["openTime"].toString()) : <any>null;
            this.closeTime = data["closeTime"] ? moment(data["closeTime"].toString()) : <any>null;
            this.isOpen = data["isOpen"] !== undefined ? data["isOpen"] : <any>null;
            this.lastCloseTime = data["lastCloseTime"] ? moment(data["lastCloseTime"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): Exchange {
        let result = new Exchange();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["currencyId"] = this.currencyId !== undefined ? this.currencyId : <any>null;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
        data["brokerId"] = this.brokerId !== undefined ? this.brokerId : <any>null;
        data["broker"] = this.broker ? this.broker.toJSON() : <any>null;
        data["timeZoneId"] = this.timeZoneId !== undefined ? this.timeZoneId : <any>null;
        data["timeZone"] = this.timeZone ? this.timeZone.toJSON() : <any>null;
        data["openTime"] = this.openTime ? this.openTime.toISOString() : <any>null;
        data["closeTime"] = this.closeTime ? this.closeTime.toISOString() : <any>null;
        data["isOpen"] = this.isOpen !== undefined ? this.isOpen : <any>null;
        data["lastCloseTime"] = this.lastCloseTime ? this.lastCloseTime.toISOString() : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface IExchange extends IBaseTable {
    name: string;
    currencyId: number;
    currency: Currency;
    brokerId: number;
    broker?: Broker | null;
    timeZoneId?: string | null;
    timeZone?: TimeZoneInfo | null;
    openTime: moment.Moment;
    closeTime: moment.Moment;
    isOpen: boolean;
    lastCloseTime: moment.Moment;
}

export class Currency extends BaseTable implements ICurrency {
    name: string;
    rate: number;
    exchanges?: Exchange[] | null;

    constructor(data?: ICurrency) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.rate = data["rate"] !== undefined ? data["rate"] : <any>null;
            if (data["exchanges"] && data["exchanges"].constructor === Array) {
                this.exchanges = [];
                for (let item of data["exchanges"])
                    this.exchanges.push(Exchange.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Currency {
        let result = new Currency();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["rate"] = this.rate !== undefined ? this.rate : <any>null;
        if (this.exchanges && this.exchanges.constructor === Array) {
            data["exchanges"] = [];
            for (let item of this.exchanges)
                data["exchanges"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ICurrency extends IBaseTable {
    name: string;
    rate: number;
    exchanges?: Exchange[] | null;
}

export class InstrumentNameResource implements IInstrumentNameResource {
    id: number;
    created?: moment.Moment | null;
    updated?: moment.Moment | null;
    name?: string | null;
    brokerSymbols?: BrokerSymbolResource[] | null;

    constructor(data?: IInstrumentNameResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.created = data["created"] ? moment(data["created"].toString()) : <any>null;
            this.updated = data["updated"] ? moment(data["updated"].toString()) : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            if (data["brokerSymbols"] && data["brokerSymbols"].constructor === Array) {
                this.brokerSymbols = [];
                for (let item of data["brokerSymbols"])
                    this.brokerSymbols.push(BrokerSymbolResource.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InstrumentNameResource {
        let result = new InstrumentNameResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["created"] = this.created ? this.created.toISOString() : <any>null;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (this.brokerSymbols && this.brokerSymbols.constructor === Array) {
            data["brokerSymbols"] = [];
            for (let item of this.brokerSymbols)
                data["brokerSymbols"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IInstrumentNameResource {
    id: number;
    created?: moment.Moment | null;
    updated?: moment.Moment | null;
    name?: string | null;
    brokerSymbols?: BrokerSymbolResource[] | null;
}

export class BrokerSymbolResource implements IBrokerSymbolResource {
    id: number;
    created?: moment.Moment | null;
    updated?: moment.Moment | null;
    instrumentNameId: number;
    name?: string | null;
    broker?: BrokerResource | null;
    brokerInstruments?: BrokerInstrumentResource[] | null;

    constructor(data?: IBrokerSymbolResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.created = data["created"] ? moment(data["created"].toString()) : <any>null;
            this.updated = data["updated"] ? moment(data["updated"].toString()) : <any>null;
            this.instrumentNameId = data["instrumentNameId"] !== undefined ? data["instrumentNameId"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.broker = data["broker"] ? BrokerResource.fromJS(data["broker"]) : <any>null;
            if (data["brokerInstruments"] && data["brokerInstruments"].constructor === Array) {
                this.brokerInstruments = [];
                for (let item of data["brokerInstruments"])
                    this.brokerInstruments.push(BrokerInstrumentResource.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BrokerSymbolResource {
        let result = new BrokerSymbolResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["created"] = this.created ? this.created.toISOString() : <any>null;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>null;
        data["instrumentNameId"] = this.instrumentNameId !== undefined ? this.instrumentNameId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["broker"] = this.broker ? this.broker.toJSON() : <any>null;
        if (this.brokerInstruments && this.brokerInstruments.constructor === Array) {
            data["brokerInstruments"] = [];
            for (let item of this.brokerInstruments)
                data["brokerInstruments"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IBrokerSymbolResource {
    id: number;
    created?: moment.Moment | null;
    updated?: moment.Moment | null;
    instrumentNameId: number;
    name?: string | null;
    broker?: BrokerResource | null;
    brokerInstruments?: BrokerInstrumentResource[] | null;
}

export class InstrumentName extends BaseTable implements IInstrumentName {
    name: string;
    brokerSymbols?: BrokerSymbol[] | null;

    constructor(data?: IInstrumentName) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            if (data["brokerSymbols"] && data["brokerSymbols"].constructor === Array) {
                this.brokerSymbols = [];
                for (let item of data["brokerSymbols"])
                    this.brokerSymbols.push(BrokerSymbol.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InstrumentName {
        let result = new InstrumentName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (this.brokerSymbols && this.brokerSymbols.constructor === Array) {
            data["brokerSymbols"] = [];
            for (let item of this.brokerSymbols)
                data["brokerSymbols"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IInstrumentName extends IBaseTable {
    name: string;
    brokerSymbols?: BrokerSymbol[] | null;
}

export class BrokerSymbol extends BaseTable implements IBrokerSymbol {
    exchangeId: number;
    instrumentNameId: number;
    name: string;
    exchange?: Exchange | null;
    instrumentName?: InstrumentName | null;
    brokerInstruments?: BrokerInstrument[] | null;

    constructor(data?: IBrokerSymbol) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.exchangeId = data["exchangeId"] !== undefined ? data["exchangeId"] : <any>null;
            this.instrumentNameId = data["instrumentNameId"] !== undefined ? data["instrumentNameId"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.exchange = data["exchange"] ? Exchange.fromJS(data["exchange"]) : <any>null;
            this.instrumentName = data["instrumentName"] ? InstrumentName.fromJS(data["instrumentName"]) : <any>null;
            if (data["brokerInstruments"] && data["brokerInstruments"].constructor === Array) {
                this.brokerInstruments = [];
                for (let item of data["brokerInstruments"])
                    this.brokerInstruments.push(BrokerInstrument.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BrokerSymbol {
        let result = new BrokerSymbol();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exchangeId"] = this.exchangeId !== undefined ? this.exchangeId : <any>null;
        data["instrumentNameId"] = this.instrumentNameId !== undefined ? this.instrumentNameId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["exchange"] = this.exchange ? this.exchange.toJSON() : <any>null;
        data["instrumentName"] = this.instrumentName ? this.instrumentName.toJSON() : <any>null;
        if (this.brokerInstruments && this.brokerInstruments.constructor === Array) {
            data["brokerInstruments"] = [];
            for (let item of this.brokerInstruments)
                data["brokerInstruments"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IBrokerSymbol extends IBaseTable {
    exchangeId: number;
    instrumentNameId: number;
    name: string;
    exchange?: Exchange | null;
    instrumentName?: InstrumentName | null;
    brokerInstruments?: BrokerInstrument[] | null;
}

export class BrokerInstrument extends BaseTable implements IBrokerInstrument {
    brokerSymbolId: number;
    instrumentTypeId: number;
    expiry?: string | null;
    multiplicator?: number | null;
    instrumentType?: InstrumentType | null;
    brokerSymbol?: BrokerSymbol | null;
    priceEntries?: PriceEntry[] | null;
    brokerInstrumentScreenerTypes?: BrokerInstrumentScreenerType[] | null;
    screenerLines?: ScreenerLine[] | null;

    constructor(data?: IBrokerInstrument) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.brokerSymbolId = data["brokerSymbolId"] !== undefined ? data["brokerSymbolId"] : <any>null;
            this.instrumentTypeId = data["instrumentTypeId"] !== undefined ? data["instrumentTypeId"] : <any>null;
            this.expiry = data["expiry"] !== undefined ? data["expiry"] : <any>null;
            this.multiplicator = data["multiplicator"] !== undefined ? data["multiplicator"] : <any>null;
            this.instrumentType = data["instrumentType"] ? InstrumentType.fromJS(data["instrumentType"]) : <any>null;
            this.brokerSymbol = data["brokerSymbol"] ? BrokerSymbol.fromJS(data["brokerSymbol"]) : <any>null;
            if (data["priceEntries"] && data["priceEntries"].constructor === Array) {
                this.priceEntries = [];
                for (let item of data["priceEntries"])
                    this.priceEntries.push(PriceEntry.fromJS(item));
            }
            if (data["brokerInstrumentScreenerTypes"] && data["brokerInstrumentScreenerTypes"].constructor === Array) {
                this.brokerInstrumentScreenerTypes = [];
                for (let item of data["brokerInstrumentScreenerTypes"])
                    this.brokerInstrumentScreenerTypes.push(BrokerInstrumentScreenerType.fromJS(item));
            }
            if (data["screenerLines"] && data["screenerLines"].constructor === Array) {
                this.screenerLines = [];
                for (let item of data["screenerLines"])
                    this.screenerLines.push(ScreenerLine.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BrokerInstrument {
        let result = new BrokerInstrument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brokerSymbolId"] = this.brokerSymbolId !== undefined ? this.brokerSymbolId : <any>null;
        data["instrumentTypeId"] = this.instrumentTypeId !== undefined ? this.instrumentTypeId : <any>null;
        data["expiry"] = this.expiry !== undefined ? this.expiry : <any>null;
        data["multiplicator"] = this.multiplicator !== undefined ? this.multiplicator : <any>null;
        data["instrumentType"] = this.instrumentType ? this.instrumentType.toJSON() : <any>null;
        data["brokerSymbol"] = this.brokerSymbol ? this.brokerSymbol.toJSON() : <any>null;
        if (this.priceEntries && this.priceEntries.constructor === Array) {
            data["priceEntries"] = [];
            for (let item of this.priceEntries)
                data["priceEntries"].push(item.toJSON());
        }
        if (this.brokerInstrumentScreenerTypes && this.brokerInstrumentScreenerTypes.constructor === Array) {
            data["brokerInstrumentScreenerTypes"] = [];
            for (let item of this.brokerInstrumentScreenerTypes)
                data["brokerInstrumentScreenerTypes"].push(item.toJSON());
        }
        if (this.screenerLines && this.screenerLines.constructor === Array) {
            data["screenerLines"] = [];
            for (let item of this.screenerLines)
                data["screenerLines"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IBrokerInstrument extends IBaseTable {
    brokerSymbolId: number;
    instrumentTypeId: number;
    expiry?: string | null;
    multiplicator?: number | null;
    instrumentType?: InstrumentType | null;
    brokerSymbol?: BrokerSymbol | null;
    priceEntries?: PriceEntry[] | null;
    brokerInstrumentScreenerTypes?: BrokerInstrumentScreenerType[] | null;
    screenerLines?: ScreenerLine[] | null;
}

export class InstrumentType extends BaseTable implements IInstrumentType {
    name: string;

    constructor(data?: IInstrumentType) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): InstrumentType {
        let result = new InstrumentType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface IInstrumentType extends IBaseTable {
    name: string;
}

export class PriceEntry extends BaseTable implements IPriceEntry {
    open: number;
    high: number;
    low: number;
    close: number;
    volume?: number | null;
    timeStamp: moment.Moment;
    isFinished: boolean;
    timeIntervalId: number;
    brokerInstrumentId: number;
    timeInterval?: TimeInterval | null;
    brokerInstrument?: BrokerInstrument | null;
    indicatorEntries?: IndicatorEntry[] | null;

    constructor(data?: IPriceEntry) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.open = data["open"] !== undefined ? data["open"] : <any>null;
            this.high = data["high"] !== undefined ? data["high"] : <any>null;
            this.low = data["low"] !== undefined ? data["low"] : <any>null;
            this.close = data["close"] !== undefined ? data["close"] : <any>null;
            this.volume = data["volume"] !== undefined ? data["volume"] : <any>null;
            this.timeStamp = data["timeStamp"] ? moment(data["timeStamp"].toString()) : <any>null;
            this.isFinished = data["isFinished"] !== undefined ? data["isFinished"] : <any>null;
            this.timeIntervalId = data["timeIntervalId"] !== undefined ? data["timeIntervalId"] : <any>null;
            this.brokerInstrumentId = data["brokerInstrumentId"] !== undefined ? data["brokerInstrumentId"] : <any>null;
            this.timeInterval = data["timeInterval"] ? TimeInterval.fromJS(data["timeInterval"]) : <any>null;
            this.brokerInstrument = data["brokerInstrument"] ? BrokerInstrument.fromJS(data["brokerInstrument"]) : <any>null;
            if (data["indicatorEntries"] && data["indicatorEntries"].constructor === Array) {
                this.indicatorEntries = [];
                for (let item of data["indicatorEntries"])
                    this.indicatorEntries.push(IndicatorEntry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PriceEntry {
        let result = new PriceEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["open"] = this.open !== undefined ? this.open : <any>null;
        data["high"] = this.high !== undefined ? this.high : <any>null;
        data["low"] = this.low !== undefined ? this.low : <any>null;
        data["close"] = this.close !== undefined ? this.close : <any>null;
        data["volume"] = this.volume !== undefined ? this.volume : <any>null;
        data["timeStamp"] = this.timeStamp ? this.timeStamp.toISOString() : <any>null;
        data["isFinished"] = this.isFinished !== undefined ? this.isFinished : <any>null;
        data["timeIntervalId"] = this.timeIntervalId !== undefined ? this.timeIntervalId : <any>null;
        data["brokerInstrumentId"] = this.brokerInstrumentId !== undefined ? this.brokerInstrumentId : <any>null;
        data["timeInterval"] = this.timeInterval ? this.timeInterval.toJSON() : <any>null;
        data["brokerInstrument"] = this.brokerInstrument ? this.brokerInstrument.toJSON() : <any>null;
        if (this.indicatorEntries && this.indicatorEntries.constructor === Array) {
            data["indicatorEntries"] = [];
            for (let item of this.indicatorEntries)
                data["indicatorEntries"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IPriceEntry extends IBaseTable {
    open: number;
    high: number;
    low: number;
    close: number;
    volume?: number | null;
    timeStamp: moment.Moment;
    isFinished: boolean;
    timeIntervalId: number;
    brokerInstrumentId: number;
    timeInterval?: TimeInterval | null;
    brokerInstrument?: BrokerInstrument | null;
    indicatorEntries?: IndicatorEntry[] | null;
}

export class IndicatorEntry extends BaseTable implements IIndicatorEntry {
    priceEntryId: number;
    isDirty: boolean;
    type: IndicatorDataType;
    data: number;
    priceEntry?: PriceEntry | null;

    constructor(data?: IIndicatorEntry) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.priceEntryId = data["priceEntryId"] !== undefined ? data["priceEntryId"] : <any>null;
            this.isDirty = data["isDirty"] !== undefined ? data["isDirty"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
            this.data = data["data"] !== undefined ? data["data"] : <any>null;
            this.priceEntry = data["priceEntry"] ? PriceEntry.fromJS(data["priceEntry"]) : <any>null;
        }
    }

    static fromJS(data: any): IndicatorEntry {
        let result = new IndicatorEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["priceEntryId"] = this.priceEntryId !== undefined ? this.priceEntryId : <any>null;
        data["isDirty"] = this.isDirty !== undefined ? this.isDirty : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["data"] = this.data !== undefined ? this.data : <any>null;
        data["priceEntry"] = this.priceEntry ? this.priceEntry.toJSON() : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface IIndicatorEntry extends IBaseTable {
    priceEntryId: number;
    isDirty: boolean;
    type: IndicatorDataType;
    data: number;
    priceEntry?: PriceEntry | null;
}

export enum IndicatorDataType {
    Wolke_SpanA = 0, 
    Wolke_SpanB = 1, 
    OrigWolke_SpanA = 2, 
    OrigWolke_SpanB = 3, 
}

export class BrokerInstrumentScreenerType extends BaseTable implements IBrokerInstrumentScreenerType {
    brokerInstrumentId: number;
    screenerTypeId: number;
    brokerInstrument?: BrokerInstrument | null;
    screenerType?: ScreenerType | null;

    constructor(data?: IBrokerInstrumentScreenerType) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.brokerInstrumentId = data["brokerInstrumentId"] !== undefined ? data["brokerInstrumentId"] : <any>null;
            this.screenerTypeId = data["screenerTypeId"] !== undefined ? data["screenerTypeId"] : <any>null;
            this.brokerInstrument = data["brokerInstrument"] ? BrokerInstrument.fromJS(data["brokerInstrument"]) : <any>null;
            this.screenerType = data["screenerType"] ? ScreenerType.fromJS(data["screenerType"]) : <any>null;
        }
    }

    static fromJS(data: any): BrokerInstrumentScreenerType {
        let result = new BrokerInstrumentScreenerType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brokerInstrumentId"] = this.brokerInstrumentId !== undefined ? this.brokerInstrumentId : <any>null;
        data["screenerTypeId"] = this.screenerTypeId !== undefined ? this.screenerTypeId : <any>null;
        data["brokerInstrument"] = this.brokerInstrument ? this.brokerInstrument.toJSON() : <any>null;
        data["screenerType"] = this.screenerType ? this.screenerType.toJSON() : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface IBrokerInstrumentScreenerType extends IBaseTable {
    brokerInstrumentId: number;
    screenerTypeId: number;
    brokerInstrument?: BrokerInstrument | null;
    screenerType?: ScreenerType | null;
}

export class ScreenerType extends BaseTable implements IScreenerType {
    name?: string | null;
    url?: string | null;
    path?: string | null;
    lastHash?: string | null;
    lastResult?: string | null;
    markerRed?: number | null;
    markerGreen?: number | null;
    markerBlue?: number | null;
    timeInterval?: TimeInterval | null;
    nameColumn: number;
    lastCheck: moment.Moment;
    updateFrequencyTicks: number;
    useToday: boolean;
    updateFrequency: moment.Moment;
    screenerEntryMappings?: ScreenerEntryMapping[] | null;
    screeners?: Screener[] | null;
    screenerReferenceImages?: ScreenerReferenceImage[] | null;
    brokerInstrumentScreenerTypes?: BrokerInstrumentScreenerType[] | null;

    constructor(data?: IScreenerType) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.url = data["url"] !== undefined ? data["url"] : <any>null;
            this.path = data["path"] !== undefined ? data["path"] : <any>null;
            this.lastHash = data["lastHash"] !== undefined ? data["lastHash"] : <any>null;
            this.lastResult = data["lastResult"] !== undefined ? data["lastResult"] : <any>null;
            this.markerRed = data["markerRed"] !== undefined ? data["markerRed"] : <any>null;
            this.markerGreen = data["markerGreen"] !== undefined ? data["markerGreen"] : <any>null;
            this.markerBlue = data["markerBlue"] !== undefined ? data["markerBlue"] : <any>null;
            this.timeInterval = data["timeInterval"] ? TimeInterval.fromJS(data["timeInterval"]) : <any>null;
            this.nameColumn = data["nameColumn"] !== undefined ? data["nameColumn"] : <any>null;
            this.lastCheck = data["lastCheck"] ? moment(data["lastCheck"].toString()) : <any>null;
            this.updateFrequencyTicks = data["updateFrequencyTicks"] !== undefined ? data["updateFrequencyTicks"] : <any>null;
            this.useToday = data["useToday"] !== undefined ? data["useToday"] : <any>null;
            this.updateFrequency = data["updateFrequency"] ? moment(data["updateFrequency"].toString()) : <any>null;
            if (data["screenerEntryMappings"] && data["screenerEntryMappings"].constructor === Array) {
                this.screenerEntryMappings = [];
                for (let item of data["screenerEntryMappings"])
                    this.screenerEntryMappings.push(ScreenerEntryMapping.fromJS(item));
            }
            if (data["screeners"] && data["screeners"].constructor === Array) {
                this.screeners = [];
                for (let item of data["screeners"])
                    this.screeners.push(Screener.fromJS(item));
            }
            if (data["screenerReferenceImages"] && data["screenerReferenceImages"].constructor === Array) {
                this.screenerReferenceImages = [];
                for (let item of data["screenerReferenceImages"])
                    this.screenerReferenceImages.push(ScreenerReferenceImage.fromJS(item));
            }
            if (data["brokerInstrumentScreenerTypes"] && data["brokerInstrumentScreenerTypes"].constructor === Array) {
                this.brokerInstrumentScreenerTypes = [];
                for (let item of data["brokerInstrumentScreenerTypes"])
                    this.brokerInstrumentScreenerTypes.push(BrokerInstrumentScreenerType.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ScreenerType {
        let result = new ScreenerType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["url"] = this.url !== undefined ? this.url : <any>null;
        data["path"] = this.path !== undefined ? this.path : <any>null;
        data["lastHash"] = this.lastHash !== undefined ? this.lastHash : <any>null;
        data["lastResult"] = this.lastResult !== undefined ? this.lastResult : <any>null;
        data["markerRed"] = this.markerRed !== undefined ? this.markerRed : <any>null;
        data["markerGreen"] = this.markerGreen !== undefined ? this.markerGreen : <any>null;
        data["markerBlue"] = this.markerBlue !== undefined ? this.markerBlue : <any>null;
        data["timeInterval"] = this.timeInterval ? this.timeInterval.toJSON() : <any>null;
        data["nameColumn"] = this.nameColumn !== undefined ? this.nameColumn : <any>null;
        data["lastCheck"] = this.lastCheck ? this.lastCheck.toISOString() : <any>null;
        data["updateFrequencyTicks"] = this.updateFrequencyTicks !== undefined ? this.updateFrequencyTicks : <any>null;
        data["useToday"] = this.useToday !== undefined ? this.useToday : <any>null;
        data["updateFrequency"] = this.updateFrequency ? this.updateFrequency.toISOString() : <any>null;
        if (this.screenerEntryMappings && this.screenerEntryMappings.constructor === Array) {
            data["screenerEntryMappings"] = [];
            for (let item of this.screenerEntryMappings)
                data["screenerEntryMappings"].push(item.toJSON());
        }
        if (this.screeners && this.screeners.constructor === Array) {
            data["screeners"] = [];
            for (let item of this.screeners)
                data["screeners"].push(item.toJSON());
        }
        if (this.screenerReferenceImages && this.screenerReferenceImages.constructor === Array) {
            data["screenerReferenceImages"] = [];
            for (let item of this.screenerReferenceImages)
                data["screenerReferenceImages"].push(item.toJSON());
        }
        if (this.brokerInstrumentScreenerTypes && this.brokerInstrumentScreenerTypes.constructor === Array) {
            data["brokerInstrumentScreenerTypes"] = [];
            for (let item of this.brokerInstrumentScreenerTypes)
                data["brokerInstrumentScreenerTypes"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IScreenerType extends IBaseTable {
    name?: string | null;
    url?: string | null;
    path?: string | null;
    lastHash?: string | null;
    lastResult?: string | null;
    markerRed?: number | null;
    markerGreen?: number | null;
    markerBlue?: number | null;
    timeInterval?: TimeInterval | null;
    nameColumn: number;
    lastCheck: moment.Moment;
    updateFrequencyTicks: number;
    useToday: boolean;
    updateFrequency: moment.Moment;
    screenerEntryMappings?: ScreenerEntryMapping[] | null;
    screeners?: Screener[] | null;
    screenerReferenceImages?: ScreenerReferenceImage[] | null;
    brokerInstrumentScreenerTypes?: BrokerInstrumentScreenerType[] | null;
}

export class ScreenerEntryMapping extends BaseTable implements IScreenerEntryMapping {
    position: number;
    active: boolean;
    screenerTypeId: number;
    screenerEntryTypeId: number;
    screenerType?: ScreenerType | null;
    screenerEntryType?: ScreenerEntryType | null;

    constructor(data?: IScreenerEntryMapping) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.position = data["position"] !== undefined ? data["position"] : <any>null;
            this.active = data["active"] !== undefined ? data["active"] : <any>null;
            this.screenerTypeId = data["screenerTypeId"] !== undefined ? data["screenerTypeId"] : <any>null;
            this.screenerEntryTypeId = data["screenerEntryTypeId"] !== undefined ? data["screenerEntryTypeId"] : <any>null;
            this.screenerType = data["screenerType"] ? ScreenerType.fromJS(data["screenerType"]) : <any>null;
            this.screenerEntryType = data["screenerEntryType"] ? ScreenerEntryType.fromJS(data["screenerEntryType"]) : <any>null;
        }
    }

    static fromJS(data: any): ScreenerEntryMapping {
        let result = new ScreenerEntryMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["position"] = this.position !== undefined ? this.position : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["screenerTypeId"] = this.screenerTypeId !== undefined ? this.screenerTypeId : <any>null;
        data["screenerEntryTypeId"] = this.screenerEntryTypeId !== undefined ? this.screenerEntryTypeId : <any>null;
        data["screenerType"] = this.screenerType ? this.screenerType.toJSON() : <any>null;
        data["screenerEntryType"] = this.screenerEntryType ? this.screenerEntryType.toJSON() : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface IScreenerEntryMapping extends IBaseTable {
    position: number;
    active: boolean;
    screenerTypeId: number;
    screenerEntryTypeId: number;
    screenerType?: ScreenerType | null;
    screenerEntryType?: ScreenerEntryType | null;
}

export class ScreenerEntryType extends BaseTable implements IScreenerEntryType {
    name: string;
    screenerEntryMappings?: ScreenerEntryMapping[] | null;

    constructor(data?: IScreenerEntryType) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            if (data["screenerEntryMappings"] && data["screenerEntryMappings"].constructor === Array) {
                this.screenerEntryMappings = [];
                for (let item of data["screenerEntryMappings"])
                    this.screenerEntryMappings.push(ScreenerEntryMapping.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ScreenerEntryType {
        let result = new ScreenerEntryType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (this.screenerEntryMappings && this.screenerEntryMappings.constructor === Array) {
            data["screenerEntryMappings"] = [];
            for (let item of this.screenerEntryMappings)
                data["screenerEntryMappings"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IScreenerEntryType extends IBaseTable {
    name: string;
    screenerEntryMappings?: ScreenerEntryMapping[] | null;
}

export class Screener extends BaseTable implements IScreener {
    prevId?: number | null;
    nextId?: number | null;
    timeStamp: moment.Moment;
    imageFile?: string | null;
    isProcessed: boolean;
    imageHash?: string | null;
    parseError: boolean;
    parseErrorString?: string | null;
    screenerTypeId: number;
    screenerType?: ScreenerType | null;
    screenerLines?: ScreenerLine[] | null;

    constructor(data?: IScreener) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.prevId = data["prevId"] !== undefined ? data["prevId"] : <any>null;
            this.nextId = data["nextId"] !== undefined ? data["nextId"] : <any>null;
            this.timeStamp = data["timeStamp"] ? moment(data["timeStamp"].toString()) : <any>null;
            this.imageFile = data["imageFile"] !== undefined ? data["imageFile"] : <any>null;
            this.isProcessed = data["isProcessed"] !== undefined ? data["isProcessed"] : <any>null;
            this.imageHash = data["imageHash"] !== undefined ? data["imageHash"] : <any>null;
            this.parseError = data["parseError"] !== undefined ? data["parseError"] : <any>null;
            this.parseErrorString = data["parseErrorString"] !== undefined ? data["parseErrorString"] : <any>null;
            this.screenerTypeId = data["screenerTypeId"] !== undefined ? data["screenerTypeId"] : <any>null;
            this.screenerType = data["screenerType"] ? ScreenerType.fromJS(data["screenerType"]) : <any>null;
            if (data["screenerLines"] && data["screenerLines"].constructor === Array) {
                this.screenerLines = [];
                for (let item of data["screenerLines"])
                    this.screenerLines.push(ScreenerLine.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Screener {
        let result = new Screener();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["prevId"] = this.prevId !== undefined ? this.prevId : <any>null;
        data["nextId"] = this.nextId !== undefined ? this.nextId : <any>null;
        data["timeStamp"] = this.timeStamp ? this.timeStamp.toISOString() : <any>null;
        data["imageFile"] = this.imageFile !== undefined ? this.imageFile : <any>null;
        data["isProcessed"] = this.isProcessed !== undefined ? this.isProcessed : <any>null;
        data["imageHash"] = this.imageHash !== undefined ? this.imageHash : <any>null;
        data["parseError"] = this.parseError !== undefined ? this.parseError : <any>null;
        data["parseErrorString"] = this.parseErrorString !== undefined ? this.parseErrorString : <any>null;
        data["screenerTypeId"] = this.screenerTypeId !== undefined ? this.screenerTypeId : <any>null;
        data["screenerType"] = this.screenerType ? this.screenerType.toJSON() : <any>null;
        if (this.screenerLines && this.screenerLines.constructor === Array) {
            data["screenerLines"] = [];
            for (let item of this.screenerLines)
                data["screenerLines"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IScreener extends IBaseTable {
    prevId?: number | null;
    nextId?: number | null;
    timeStamp: moment.Moment;
    imageFile?: string | null;
    isProcessed: boolean;
    imageHash?: string | null;
    parseError: boolean;
    parseErrorString?: string | null;
    screenerTypeId: number;
    screenerType?: ScreenerType | null;
    screenerLines?: ScreenerLine[] | null;
}

export class ScreenerLine extends BaseTable implements IScreenerLine {
    brokerInstrumentId: number;
    screenerId: number;
    brokerInstrument?: BrokerInstrument | null;
    screener?: Screener | null;
    screenerEntries?: ScreenerEntry[] | null;

    constructor(data?: IScreenerLine) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.brokerInstrumentId = data["brokerInstrumentId"] !== undefined ? data["brokerInstrumentId"] : <any>null;
            this.screenerId = data["screenerId"] !== undefined ? data["screenerId"] : <any>null;
            this.brokerInstrument = data["brokerInstrument"] ? BrokerInstrument.fromJS(data["brokerInstrument"]) : <any>null;
            this.screener = data["screener"] ? Screener.fromJS(data["screener"]) : <any>null;
            if (data["screenerEntries"] && data["screenerEntries"].constructor === Array) {
                this.screenerEntries = [];
                for (let item of data["screenerEntries"])
                    this.screenerEntries.push(ScreenerEntry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ScreenerLine {
        let result = new ScreenerLine();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brokerInstrumentId"] = this.brokerInstrumentId !== undefined ? this.brokerInstrumentId : <any>null;
        data["screenerId"] = this.screenerId !== undefined ? this.screenerId : <any>null;
        data["brokerInstrument"] = this.brokerInstrument ? this.brokerInstrument.toJSON() : <any>null;
        data["screener"] = this.screener ? this.screener.toJSON() : <any>null;
        if (this.screenerEntries && this.screenerEntries.constructor === Array) {
            data["screenerEntries"] = [];
            for (let item of this.screenerEntries)
                data["screenerEntries"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IScreenerLine extends IBaseTable {
    brokerInstrumentId: number;
    screenerId: number;
    brokerInstrument?: BrokerInstrument | null;
    screener?: Screener | null;
    screenerEntries?: ScreenerEntry[] | null;
}

export class ScreenerEntry extends BaseTable implements IScreenerEntry {
    fg: CellColor;
    bg: CellColor;
    value?: number | null;
    screenerEntryTypeId: number;
    screenerLineId: number;
    screenerEntryType?: ScreenerEntryType | null;
    screenerLine?: ScreenerLine | null;

    constructor(data?: IScreenerEntry) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.fg = data["fg"] !== undefined ? data["fg"] : <any>null;
            this.bg = data["bg"] !== undefined ? data["bg"] : <any>null;
            this.value = data["value"] !== undefined ? data["value"] : <any>null;
            this.screenerEntryTypeId = data["screenerEntryTypeId"] !== undefined ? data["screenerEntryTypeId"] : <any>null;
            this.screenerLineId = data["screenerLineId"] !== undefined ? data["screenerLineId"] : <any>null;
            this.screenerEntryType = data["screenerEntryType"] ? ScreenerEntryType.fromJS(data["screenerEntryType"]) : <any>null;
            this.screenerLine = data["screenerLine"] ? ScreenerLine.fromJS(data["screenerLine"]) : <any>null;
        }
    }

    static fromJS(data: any): ScreenerEntry {
        let result = new ScreenerEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fg"] = this.fg !== undefined ? this.fg : <any>null;
        data["bg"] = this.bg !== undefined ? this.bg : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        data["screenerEntryTypeId"] = this.screenerEntryTypeId !== undefined ? this.screenerEntryTypeId : <any>null;
        data["screenerLineId"] = this.screenerLineId !== undefined ? this.screenerLineId : <any>null;
        data["screenerEntryType"] = this.screenerEntryType ? this.screenerEntryType.toJSON() : <any>null;
        data["screenerLine"] = this.screenerLine ? this.screenerLine.toJSON() : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface IScreenerEntry extends IBaseTable {
    fg: CellColor;
    bg: CellColor;
    value?: number | null;
    screenerEntryTypeId: number;
    screenerLineId: number;
    screenerEntryType?: ScreenerEntryType | null;
    screenerLine?: ScreenerLine | null;
}

export enum CellColor {
    Undefined = 0, 
    Red = 1, 
    Green = 2, 
    Black = 3, 
    White = 4, 
    DarkGreen = 5, 
    Yellow = 6, 
}

export class ScreenerReferenceImage extends BaseTable implements IScreenerReferenceImage {
    brokerInstrumentId?: number | null;
    screenerTypeId: number;
    imageSignature?: string | null;
    brokerInstrument?: BrokerInstrument | null;
    screenerType?: ScreenerType | null;
    cellColor: CellColor;
    unused: boolean;

    constructor(data?: IScreenerReferenceImage) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.brokerInstrumentId = data["brokerInstrumentId"] !== undefined ? data["brokerInstrumentId"] : <any>null;
            this.screenerTypeId = data["screenerTypeId"] !== undefined ? data["screenerTypeId"] : <any>null;
            this.imageSignature = data["imageSignature"] !== undefined ? data["imageSignature"] : <any>null;
            this.brokerInstrument = data["brokerInstrument"] ? BrokerInstrument.fromJS(data["brokerInstrument"]) : <any>null;
            this.screenerType = data["screenerType"] ? ScreenerType.fromJS(data["screenerType"]) : <any>null;
            this.cellColor = data["cellColor"] !== undefined ? data["cellColor"] : <any>null;
            this.unused = data["unused"] !== undefined ? data["unused"] : <any>null;
        }
    }

    static fromJS(data: any): ScreenerReferenceImage {
        let result = new ScreenerReferenceImage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brokerInstrumentId"] = this.brokerInstrumentId !== undefined ? this.brokerInstrumentId : <any>null;
        data["screenerTypeId"] = this.screenerTypeId !== undefined ? this.screenerTypeId : <any>null;
        data["imageSignature"] = this.imageSignature !== undefined ? this.imageSignature : <any>null;
        data["brokerInstrument"] = this.brokerInstrument ? this.brokerInstrument.toJSON() : <any>null;
        data["screenerType"] = this.screenerType ? this.screenerType.toJSON() : <any>null;
        data["cellColor"] = this.cellColor !== undefined ? this.cellColor : <any>null;
        data["unused"] = this.unused !== undefined ? this.unused : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface IScreenerReferenceImage extends IBaseTable {
    brokerInstrumentId?: number | null;
    screenerTypeId: number;
    imageSignature?: string | null;
    brokerInstrument?: BrokerInstrument | null;
    screenerType?: ScreenerType | null;
    cellColor: CellColor;
    unused: boolean;
}

export class ActionResult implements IActionResult {

    constructor(data?: IActionResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): ActionResult {
        let result = new ActionResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IActionResult {
}

export class SignalResource implements ISignalResource {
    id: number;
    signalType: SignalType;
    tradeDirection: TradeDirection;
    brokerInstrumentId: number;
    timeIntervalId: number;
    instrument?: InstrumentNameAllResource | null;
    timeInterval?: TimeInterval | null;
    signalSteps?: SignalStepResource[] | null;
    trades?: TradeResource[] | null;
    entry?: number | null;
    stop?: number | null;
    profit?: number | null;
    lastTime?: moment.Moment | null;

    constructor(data?: ISignalResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.signalType = data["signalType"] !== undefined ? data["signalType"] : <any>null;
            this.tradeDirection = data["tradeDirection"] !== undefined ? data["tradeDirection"] : <any>null;
            this.brokerInstrumentId = data["brokerInstrumentId"] !== undefined ? data["brokerInstrumentId"] : <any>null;
            this.timeIntervalId = data["timeIntervalId"] !== undefined ? data["timeIntervalId"] : <any>null;
            this.instrument = data["instrument"] ? InstrumentNameAllResource.fromJS(data["instrument"]) : <any>null;
            this.timeInterval = data["timeInterval"] ? TimeInterval.fromJS(data["timeInterval"]) : <any>null;
            if (data["signalSteps"] && data["signalSteps"].constructor === Array) {
                this.signalSteps = [];
                for (let item of data["signalSteps"])
                    this.signalSteps.push(SignalStepResource.fromJS(item));
            }
            if (data["trades"] && data["trades"].constructor === Array) {
                this.trades = [];
                for (let item of data["trades"])
                    this.trades.push(TradeResource.fromJS(item));
            }
            this.entry = data["entry"] !== undefined ? data["entry"] : <any>null;
            this.stop = data["stop"] !== undefined ? data["stop"] : <any>null;
            this.profit = data["profit"] !== undefined ? data["profit"] : <any>null;
            this.lastTime = data["lastTime"] ? moment(data["lastTime"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): SignalResource {
        let result = new SignalResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["signalType"] = this.signalType !== undefined ? this.signalType : <any>null;
        data["tradeDirection"] = this.tradeDirection !== undefined ? this.tradeDirection : <any>null;
        data["brokerInstrumentId"] = this.brokerInstrumentId !== undefined ? this.brokerInstrumentId : <any>null;
        data["timeIntervalId"] = this.timeIntervalId !== undefined ? this.timeIntervalId : <any>null;
        data["instrument"] = this.instrument ? this.instrument.toJSON() : <any>null;
        data["timeInterval"] = this.timeInterval ? this.timeInterval.toJSON() : <any>null;
        if (this.signalSteps && this.signalSteps.constructor === Array) {
            data["signalSteps"] = [];
            for (let item of this.signalSteps)
                data["signalSteps"].push(item.toJSON());
        }
        if (this.trades && this.trades.constructor === Array) {
            data["trades"] = [];
            for (let item of this.trades)
                data["trades"].push(item.toJSON());
        }
        data["entry"] = this.entry !== undefined ? this.entry : <any>null;
        data["stop"] = this.stop !== undefined ? this.stop : <any>null;
        data["profit"] = this.profit !== undefined ? this.profit : <any>null;
        data["lastTime"] = this.lastTime ? this.lastTime.toISOString() : <any>null;
        return data; 
    }
}

export interface ISignalResource {
    id: number;
    signalType: SignalType;
    tradeDirection: TradeDirection;
    brokerInstrumentId: number;
    timeIntervalId: number;
    instrument?: InstrumentNameAllResource | null;
    timeInterval?: TimeInterval | null;
    signalSteps?: SignalStepResource[] | null;
    trades?: TradeResource[] | null;
    entry?: number | null;
    stop?: number | null;
    profit?: number | null;
    lastTime?: moment.Moment | null;
}

export enum SignalType {
    Icer = 0, 
    UNL = 1, 
}

export enum TradeDirection {
    Long = 1, 
    Short = -1, 
}

export class SignalStepResource implements ISignalStepResource {
    id: number;
    signalStepType: SignalStepType;
    signalId: number;
    signal?: SignalResource | null;
    priceEntryId: number;
    priceEntry?: PriceEntryResource | null;
    entryType?: EntryType | null;
    entry?: number | null;
    sl?: number | null;
    tp?: number | null;
    slType?: StopLossType | null;
    exitType?: ExitType | null;
    reason?: string | null;
    created: moment.Moment;
    updated: moment.Moment;

    constructor(data?: ISignalStepResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.signalStepType = data["signalStepType"] !== undefined ? data["signalStepType"] : <any>null;
            this.signalId = data["signalId"] !== undefined ? data["signalId"] : <any>null;
            this.signal = data["signal"] ? SignalResource.fromJS(data["signal"]) : <any>null;
            this.priceEntryId = data["priceEntryId"] !== undefined ? data["priceEntryId"] : <any>null;
            this.priceEntry = data["priceEntry"] ? PriceEntryResource.fromJS(data["priceEntry"]) : <any>null;
            this.entryType = data["entryType"] !== undefined ? data["entryType"] : <any>null;
            this.entry = data["entry"] !== undefined ? data["entry"] : <any>null;
            this.sl = data["sl"] !== undefined ? data["sl"] : <any>null;
            this.tp = data["tp"] !== undefined ? data["tp"] : <any>null;
            this.slType = data["slType"] !== undefined ? data["slType"] : <any>null;
            this.exitType = data["exitType"] !== undefined ? data["exitType"] : <any>null;
            this.reason = data["reason"] !== undefined ? data["reason"] : <any>null;
            this.created = data["created"] ? moment(data["created"].toString()) : <any>null;
            this.updated = data["updated"] ? moment(data["updated"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): SignalStepResource {
        let result = new SignalStepResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["signalStepType"] = this.signalStepType !== undefined ? this.signalStepType : <any>null;
        data["signalId"] = this.signalId !== undefined ? this.signalId : <any>null;
        data["signal"] = this.signal ? this.signal.toJSON() : <any>null;
        data["priceEntryId"] = this.priceEntryId !== undefined ? this.priceEntryId : <any>null;
        data["priceEntry"] = this.priceEntry ? this.priceEntry.toJSON() : <any>null;
        data["entryType"] = this.entryType !== undefined ? this.entryType : <any>null;
        data["entry"] = this.entry !== undefined ? this.entry : <any>null;
        data["sl"] = this.sl !== undefined ? this.sl : <any>null;
        data["tp"] = this.tp !== undefined ? this.tp : <any>null;
        data["slType"] = this.slType !== undefined ? this.slType : <any>null;
        data["exitType"] = this.exitType !== undefined ? this.exitType : <any>null;
        data["reason"] = this.reason !== undefined ? this.reason : <any>null;
        data["created"] = this.created ? this.created.toISOString() : <any>null;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>null;
        return data; 
    }
}

export interface ISignalStepResource {
    id: number;
    signalStepType: SignalStepType;
    signalId: number;
    signal?: SignalResource | null;
    priceEntryId: number;
    priceEntry?: PriceEntryResource | null;
    entryType?: EntryType | null;
    entry?: number | null;
    sl?: number | null;
    tp?: number | null;
    slType?: StopLossType | null;
    exitType?: ExitType | null;
    reason?: string | null;
    created: moment.Moment;
    updated: moment.Moment;
}

export enum SignalStepType {
    Change = 0, 
    New = 1, 
    Cancel = -1, 
}

export enum EntryType {
    StopLimit = 1, 
    Limit = 2, 
}

export enum StopLossType {
    Icer1 = 1, 
}

export enum ExitType {
    Icer1 = 1, 
}

export class TradeResource implements ITradeResource {
    id: number;
    signalId: number;
    signal?: SignalResource | null;
    signalState: SignalState;
    size?: number | null;
    entry?: number | null;
    stop?: number | null;
    profit?: number | null;
    type?: TradeStepType | null;
    lastClose?: number | null;
    pnL?: number | null;
    atRisk?: number | null;
    percentPnL?: number | null;
    tradeSteps?: TradeStepResource[] | null;
    orders?: OrderResource[] | null;

    constructor(data?: ITradeResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.signalId = data["signalId"] !== undefined ? data["signalId"] : <any>null;
            this.signal = data["signal"] ? SignalResource.fromJS(data["signal"]) : <any>null;
            this.signalState = data["signalState"] !== undefined ? data["signalState"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.entry = data["entry"] !== undefined ? data["entry"] : <any>null;
            this.stop = data["stop"] !== undefined ? data["stop"] : <any>null;
            this.profit = data["profit"] !== undefined ? data["profit"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
            this.lastClose = data["lastClose"] !== undefined ? data["lastClose"] : <any>null;
            this.pnL = data["pnL"] !== undefined ? data["pnL"] : <any>null;
            this.atRisk = data["atRisk"] !== undefined ? data["atRisk"] : <any>null;
            this.percentPnL = data["percentPnL"] !== undefined ? data["percentPnL"] : <any>null;
            if (data["tradeSteps"] && data["tradeSteps"].constructor === Array) {
                this.tradeSteps = [];
                for (let item of data["tradeSteps"])
                    this.tradeSteps.push(TradeStepResource.fromJS(item));
            }
            if (data["orders"] && data["orders"].constructor === Array) {
                this.orders = [];
                for (let item of data["orders"])
                    this.orders.push(OrderResource.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TradeResource {
        let result = new TradeResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["signalId"] = this.signalId !== undefined ? this.signalId : <any>null;
        data["signal"] = this.signal ? this.signal.toJSON() : <any>null;
        data["signalState"] = this.signalState !== undefined ? this.signalState : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["entry"] = this.entry !== undefined ? this.entry : <any>null;
        data["stop"] = this.stop !== undefined ? this.stop : <any>null;
        data["profit"] = this.profit !== undefined ? this.profit : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["lastClose"] = this.lastClose !== undefined ? this.lastClose : <any>null;
        data["pnL"] = this.pnL !== undefined ? this.pnL : <any>null;
        data["atRisk"] = this.atRisk !== undefined ? this.atRisk : <any>null;
        data["percentPnL"] = this.percentPnL !== undefined ? this.percentPnL : <any>null;
        if (this.tradeSteps && this.tradeSteps.constructor === Array) {
            data["tradeSteps"] = [];
            for (let item of this.tradeSteps)
                data["tradeSteps"].push(item.toJSON());
        }
        if (this.orders && this.orders.constructor === Array) {
            data["orders"] = [];
            for (let item of this.orders)
                data["orders"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITradeResource {
    id: number;
    signalId: number;
    signal?: SignalResource | null;
    signalState: SignalState;
    size?: number | null;
    entry?: number | null;
    stop?: number | null;
    profit?: number | null;
    type?: TradeStepType | null;
    lastClose?: number | null;
    pnL?: number | null;
    atRisk?: number | null;
    percentPnL?: number | null;
    tradeSteps?: TradeStepResource[] | null;
    orders?: OrderResource[] | null;
}

export enum SignalState {
    Ok = 0, 
    Changed = 1, 
    Cancelled = -1, 
}

export enum TradeStepType {
    Prepped = 1, 
    PrepChange = 2, 
    PrepCancel = 3, 
    Placed = 10, 
    PlacedOld = 11, 
    Filled = 20, 
    Closed = 30, 
    TGS = 33, 
    Hide = 99, 
    Cancel = -1, 
}

export class TradeStepResource implements ITradeStepResource {
    tradeId: number;
    type: TradeStepType;
    result: TradeStepResult;
    reason?: TradeStepErrorReason | null;
    size?: number | null;
    entryLevel?: number | null;
    stopLevel?: number | null;
    profitLevel?: number | null;
    created: moment.Moment;
    updated: moment.Moment;

    constructor(data?: ITradeStepResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tradeId = data["tradeId"] !== undefined ? data["tradeId"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
            this.result = data["result"] !== undefined ? data["result"] : <any>null;
            this.reason = data["reason"] !== undefined ? data["reason"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.entryLevel = data["entryLevel"] !== undefined ? data["entryLevel"] : <any>null;
            this.stopLevel = data["stopLevel"] !== undefined ? data["stopLevel"] : <any>null;
            this.profitLevel = data["profitLevel"] !== undefined ? data["profitLevel"] : <any>null;
            this.created = data["created"] ? moment(data["created"].toString()) : <any>null;
            this.updated = data["updated"] ? moment(data["updated"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): TradeStepResource {
        let result = new TradeStepResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tradeId"] = this.tradeId !== undefined ? this.tradeId : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["result"] = this.result !== undefined ? this.result : <any>null;
        data["reason"] = this.reason !== undefined ? this.reason : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["entryLevel"] = this.entryLevel !== undefined ? this.entryLevel : <any>null;
        data["stopLevel"] = this.stopLevel !== undefined ? this.stopLevel : <any>null;
        data["profitLevel"] = this.profitLevel !== undefined ? this.profitLevel : <any>null;
        data["created"] = this.created ? this.created.toISOString() : <any>null;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>null;
        return data; 
    }
}

export interface ITradeStepResource {
    tradeId: number;
    type: TradeStepType;
    result: TradeStepResult;
    reason?: TradeStepErrorReason | null;
    size?: number | null;
    entryLevel?: number | null;
    stopLevel?: number | null;
    profitLevel?: number | null;
    created: moment.Moment;
    updated: moment.Moment;
}

export enum TradeStepResult {
    Pending = 0, 
    Ok = 1, 
    Error = -1, 
}

export enum TradeStepErrorReason {
    NoMargin = 1, 
    NoConnect = 2, 
    Unknown = -1, 
}

export class OrderResource implements IOrderResource {
    id: number;
    tradeId: number;
    trade?: TradeResource | null;
    brokerOrderId?: string | null;
    function: OrderFunction;
    type: OrderType;
    state: OrderState;
    size: number;
    limitLevel?: number | null;
    stopLevel?: number | null;
    executedLevel?: number | null;
    costs?: number | null;
    direction: TradeDirection;
    validAfter?: moment.Moment | null;

    constructor(data?: IOrderResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.tradeId = data["tradeId"] !== undefined ? data["tradeId"] : <any>null;
            this.trade = data["trade"] ? TradeResource.fromJS(data["trade"]) : <any>null;
            this.brokerOrderId = data["brokerOrderId"] !== undefined ? data["brokerOrderId"] : <any>null;
            this.function = data["function"] !== undefined ? data["function"] : <any>null;
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
            this.state = data["state"] !== undefined ? data["state"] : <any>null;
            this.size = data["size"] !== undefined ? data["size"] : <any>null;
            this.limitLevel = data["limitLevel"] !== undefined ? data["limitLevel"] : <any>null;
            this.stopLevel = data["stopLevel"] !== undefined ? data["stopLevel"] : <any>null;
            this.executedLevel = data["executedLevel"] !== undefined ? data["executedLevel"] : <any>null;
            this.costs = data["costs"] !== undefined ? data["costs"] : <any>null;
            this.direction = data["direction"] !== undefined ? data["direction"] : <any>null;
            this.validAfter = data["validAfter"] ? moment(data["validAfter"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): OrderResource {
        let result = new OrderResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["tradeId"] = this.tradeId !== undefined ? this.tradeId : <any>null;
        data["trade"] = this.trade ? this.trade.toJSON() : <any>null;
        data["brokerOrderId"] = this.brokerOrderId !== undefined ? this.brokerOrderId : <any>null;
        data["function"] = this.function !== undefined ? this.function : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["state"] = this.state !== undefined ? this.state : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["limitLevel"] = this.limitLevel !== undefined ? this.limitLevel : <any>null;
        data["stopLevel"] = this.stopLevel !== undefined ? this.stopLevel : <any>null;
        data["executedLevel"] = this.executedLevel !== undefined ? this.executedLevel : <any>null;
        data["costs"] = this.costs !== undefined ? this.costs : <any>null;
        data["direction"] = this.direction !== undefined ? this.direction : <any>null;
        data["validAfter"] = this.validAfter ? this.validAfter.toISOString() : <any>null;
        return data; 
    }
}

export interface IOrderResource {
    id: number;
    tradeId: number;
    trade?: TradeResource | null;
    brokerOrderId?: string | null;
    function: OrderFunction;
    type: OrderType;
    state: OrderState;
    size: number;
    limitLevel?: number | null;
    stopLevel?: number | null;
    executedLevel?: number | null;
    costs?: number | null;
    direction: TradeDirection;
    validAfter?: moment.Moment | null;
}

export enum OrderFunction {
    Time = 0, 
    Entry = 1, 
    TP = 2, 
    SL = -1, 
}

export enum OrderType {
    Market = 0, 
    Stop = 1, 
    StopLimit = 2, 
    Limit = 3, 
}

export enum OrderState {
    Prepared = 0, 
    Submitted = 1, 
    Rejected = 2, 
    Filled = 3, 
    Canceled = 4, 
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    result: any; 

    constructor(message: string, status: number, response: string, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.result = result;
    }
}

function throwException(message: string, status: number, response: string, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return Observable.throw(result);
    else
        return Observable.throw(new SwaggerException(message, status, response, null));
}

function blobToText(blob: Blob): Observable<string> {
    return new Observable<string>((observer: any) => { 
        let reader = new FileReader(); 
        reader.onload = function() { 
            observer.next(this.result);
            observer.complete();
        }
        reader.readAsText(blob); 
    });
}